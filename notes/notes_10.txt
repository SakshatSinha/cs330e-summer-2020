
Range and RangeIterator: 
------------------------
In RangeIteratorT we see that range_iterator_class and 
range_iterator_function are imported meaning we 
can implement the rangeIterator functionality in 
both a class and a function.
 
In RangeT we see that range_1, and range_2 are imported. 
More importantly on lines 50-51 list() is called twice 
and we get a new iterator both times! This logic can't be 
done in a function, meaning we need to make a class that responds to __iter__().

 
Range_2:
-------
Range_2 in Range.py is trying to implement a range function that is not exhaustible. 
This is can be easily achieved by not updating the instance variables b and e.
Instead you create two local variables and update them. Doing this, will keep the 
original b and e as they were when the object was initially created, and therefore,
each time you list the object, you get the same sequence of numbers (i.e., not exhaustibale).

Note that a range object is an iterable but not iterator
>>> x = range(4)
>>> hasattr(x, "__iter__")
True
>>> hasattr(x, "__next__")
False
>>> 

Range_1:
-------
Rabge_1 in Range.py accomplishes the same outcome of Range_2 but using inner classes.
Inner class is a class that is defined inside another class. 
Whenever you create an object of Range_1, you need to pass two variables, namely b and e.
Afterward, whenever you try to navigate this object, You'll get an 
instance of the inner class with the original variable values. 
------

Decorators:
----------
A decorator is a function that takes another function as an argument and adds some kind of functionality, 
and returns another function, all of this without altering the source code of the original function 
that you passed in.

Example:
def decorator_function(original_function):
	def wrapper_function():
		print('wrapper executed this before display')     
		return original_function() 
	return wrapper_function

@decorator_function # equivalent to "display = decorator_function(display)"
def display():
	print('display function ran')

display()

# output: 
wrapper executed this before display
display function ran

Note: when stacking two decorators (from top to bottom), the lower decorator is executed first.

Why?
Decorating our functions allows us to easily add functionality to our existing functions 
by adding that functionality inside the wrapper.

def post_gtz (f) :
    def g (n) :
        v = f(n)
        assert v > 0
        return v
    return g

The function post_gtz performs the work of "f" and get the result to check if its > 0. 
It transforms a function "f" to a function that checks if output greater than zero. 
That function to be returned is "g". You can think of "g" as a wrapper of "f", 
it calls "f" in its body then check if the result if greater than 0.